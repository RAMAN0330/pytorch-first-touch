# -*- coding: utf-8 -*-
"""LInear_Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R7uwoJWpIUucQmMekyc0NOcdeX3eAaxm
"""

!pip install torch

import torch
import numpy as np
import torch.nn as nn
from torch.nn import functional as F

def model(x):
  return x @ weights.t() + bias  ## @ for matrix multiplication

def loss(y_hat,y):
  diff = y_hat - y
  return torch.sum(diff * diff) / diff.numel()

factors = torch.tensor([[73,67,43],
                         [91,88,64],
                         [87,134,58],
                         [102,43,37],
                         [69,96,70]],dtype=torch.float32)

fruits_traget = torch.tensor([[56,70],
                       [81,101],
                       [119,133],
                       [22,37],
                       [103,119]],dtype=torch.float32)

weights = torch.randn(2,3,requires_grad=True)
bias = torch.randn(2,requires_grad=True)
y_hat = model(factors)  ## y_hat is the prediction
loss1 = loss(y_hat,fruits_traget) # loss is calculated
print(loss1)

learning_rate = 0.0001
loss1.backward()
with torch.no_grad():
  weights -= weights.grad * learning_rate
  bias -= bias.grad * learning_rate
  weights.grad.zero_()
  bias.grad.zero_()

weights

y_hat1 = model(factors)  ## y_hat is the prediction
loss2 = loss(y_hat1,fruits_traget) # loss is calculated
print(loss2)

"""### For dealing with large  dataset were batches are required"""

input = factors.repeat(3,1)
target = fruits_traget.repeat(3,1)

input

from torch.utils.data import TensorDataset
from torch.utils.data import DataLoader

train_ds = TensorDataset(input, target)
print(train_ds[0:3])

train_dataloder = DataLoader(train_ds , batch_size = 5, shuffle = True)

print(train_dataloder)  # Stores an object at given address

for x, y in train_dataloder:
  print(f"input is : {x} and target is : {y}")

model = nn.Linear(3,2)
print(f"weights of model are {model.weight}")
print(f"Bias of model are {model.bias}")

"""another way of checking weights and bias"""

list(model.parameters())

# Genearate predictions
preds = model(input)
preds(preds)

loss = F.mse_loss(model(input), target)
print(loss)

# Defining optimizer
opt = torch.optim.SGD(model.parameters(), lr = 0.00001)

# Defining Function for fit the data and updating weights
def fit(epoch, model, loss_fn, opt, train_dl):
  for epoch in range(epoch):
    for x, y in train_dl:
      loss = loss_fn(model(x), y)
      opt.zero_grad()
      loss.backward()
      opt.step()

    if (epoch+1) % 10 == 0:
      print(f"Epoch [{epoch+1}/{epoch}], Loss: {loss.item():.4f}")

fit(100, model, F.mse_loss, opt, train_dataloder)

preds = model(input)
print(preds , target)



